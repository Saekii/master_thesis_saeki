\documentclass[12pt]{jreport}

\input{jdummy.def}
%卒論用スタイルファイル
\usepackage{jgraduate2003_sjis}
%索引作成用
\usepackage{makeidx}
\usepackage{graphicx}
\usepackage{ascmac}
\usepackage{enumerate}

% 前設定
\date{平成27年2月}
\title{\fontsize{15.5pt}{25pt}\selectfont WLANとZigBeeの共存に向けた\\AA（Access Point-Assisted） CTS-Blockingに関する研究}
\author{佐伯 良光}
\university{九州大学大学院}
\department{システム情報科学府}
\course{修士課程}
\major{情報知能工学専攻}
\subcourse{社会情報システム工学コース}

\begin{document}
%表紙
\maketitle


\chapter{システムの設計と実装}\label{implement}%==============================================

本章では，提案するAA CTS-Blockingの設計，実装について説明する．
まず，ZigBee通信の実装に向けてUMLを用いた設計を行った．
次に，この設計を基にZigBee通信の実装を行ったので，説明する．
その後，制御PCを含めたシステム全体の実装について述べる．\\

\section{ZigBee通信の設計・実装}

本システムではZigBeeノード，ZigBee基地局にMICAを利用する．
MICAにおいて，ZigBee通信の実装はTinyOSによるイベント駆動型プログラミングとなる．
イベント駆動型プログラミングでは，起動すると共にイベントを待機し，起こったイベントに従って処理を行う．
イベントとは，プログラムの実行に際し，データを受信した，起動していたタイマが完了した等，
何らかのアクションが発生した際にプログラムに発信される信号である．
イベントを待機している間，MICAは何らかの状態を持つ．
このような状態遷移のフローをを記述するのに最適なのが，UMLのステートマシン図である．
UML(Unified Modeling Language)は，抽象化したシステムをグラフィカルな記述でモデル化し，
汎用的なプログラム設計図を与える．\\
%UMLで表現されるモデルには，システム実装を補助するために多くのダイアグラムが存在する．
本システムの設計では，システムを構成するZigBeeノード，ZigBee基地局の状態遷移を記述するためにステートマシン図を利用した．
%加えて，システム全体の流れを把握するためにシーケンス図を利用した．
以下で，詳細を説明する．

\subsection{ZigBee通信の設計}

\subsubsection{ステートマシン図}

ステートマシン図は無償UMLモデリングツールであるastah* communityを利用して作成した．
ステートマシン図の遷移は矢印で表されており，
説明はイベント［ガード条件］／アクションで記述される．
ガード条件は直前に発生したイベントの評価をするための条件である．
評価値は真もしくは偽の値を持ち，ガード条件に対して真であるときのみ遷移が許される．
アクションは遷移が起こると同時に実行される動作である．

\subsubsection{ZigBeeノード}

ステートマシン図は状態と状態遷移によって表されることを前項で説明した．
状態をSn（nは添字），イベントをEn，ガード条件をGn，アクションをAnと表記すると，
ZigBeeノードの状態遷移は以下の通りになる．

\begin{itemize}
 \item S1：受信待機状態
 \item E1：ZigBee基地局から送信要求メッセージを受信する
 \item G1：送信要求メッセージの受信成功
 \item A1：スロット時間待機するためのタイマを起動する
 \item S2：送信準備状態
 \item E2：タイマが終了する
 \item A2：データを送信する
 \item S3：送信完了状態
 \item A3：タイマをリセットする
\end{itemize}

本システムでは，ZigBee通信時間はCTS-Blockingが有効である時間に等しい．
この時間はわずかであり，送信失敗した場合にタイムアウトによる再送の仕組みを設ける余裕が無い．
従って，送信成功かどうかの判定は行わない．

これらを総合すると，ZigBeeノードのステートマシン図は
図\ref{fig:4_01}の様に描画できる．

\subsubsection{ZigBee基地局}

ノードの場合と同様に，
状態をSn，イベントをEn，ガード条件をGn，アクションをAn，と表記すると
ZigBee基地局の遷移は以下の通りになる．

\begin{itemize}
 \item S1：シリアル信号待機状態
 \item E1：制御PCから信号を受信する
 \item G1：信号の受信成功
 \item A1：CTS-Blocking有効時間を測るためのタイマを起動する
 \item S2：ブロードキャスト準備状態
 \item A2：ZigBeeノードへブロードキャストする
 \item S3：受信待機状態
 \item E3：ZigBeeノードからデータを受信する
 \item G3：データの受信成功
 \item A3：コンソールにデータを表示する
 \item S4：受信完了状態
 \item E3'，E4'：タイマが完了する
 \item A3'，A4'：タイマをリセットする
\end{itemize}

本システムでは，ZigBee通信時間はCTS-Blockingが有効である時間に等しい．
この時間はわずかであり，タイムアウトによる再送の仕組みを設ける余裕が無い．
従って，送信成功かどうかの判定は行わない．
よって，S3状態はS2状態からA2の動作を伴い自動遷移するようにした．
他方で，S4状態に遷移した後，他のノードからのデータを受信して表示する必要がある．
そのため，S4状態に入った際すぐにS3状態へと自動遷移するようにした．
そして，A1で起動させたタイマが終了した際は，S3/S4状態に関わらずS1状態に遷移する事とした．

これらを総合すると，ZigBee基地局のステートマシン図は図\ref{fig:4_02}の様に描画できる．

\subsection{ZigBee通信の実装}

\subsubsection{プラットフォーム及び開発言語}
%\subsubsection{TinyOS，nesC}

ZigBeeノード及びZigBee基地局の実装はMICAに対応するTinyOS上で行った．
TinyOSはオープンソースで開発がされているセンサネットワークノード向けのイベント駆動OSである．
%そのため，少ないリソースでも十分に動作するように設計されている．
TinyOS上で利用される，イベント駆動型プログラミング言語がnesCであり，C言語の拡張である．
nesCは一般的なプログラミング言語ではないため，
ここではnesCの基本概念について以下で説明する．

制御の流れはコンポーネントのインタフェースを通じて他のコンポーネ
ントへと流れる。これらの制御の流れはタスクやハードウエア割り込みから生じている。
・ 一連のインタフェース（interface）によるコンポーネントの動作の規定。インタフェースはコンポ
ーネントによって提供（provide）されるか利用（use）される。提供インタフェースは、コンポーネ
ントがそのユーザに提供する機能をあらわし、利用インタフェースはコンポーネントが処理を行
うために必要とする機能をあらわしている。
・ インタフェースは双方向性を持つ：インタフェースはインタフェースの提供者が実装すべき関数
群（コマンド）とインタフェースの利用者が実装すべき関数群（イベント）を示す。これにより一つ
のインタフェースでコンポーネント間の複雑なやりとりを表現することができる（例えば興味のあ
るイベントに登録しておけば、そのイベントが起こったときにコールバックされる）。TinyOS では
すべての時間のかかる処理（例：パケット送信）はノンブロッキングであるため、このことは重要
である。時間のかかる処理の完了はイベント（例：送信完了）を通じて知らされる。インタフェー
スを決めてやることによって、コンポーネントが sendDone（送信完了）イベントを実装しないで
send コマンドを呼び出せないようにすることができる。概してコマンドは呼び下げ、すなわちア
プリケーションコンポーネントからハードウエアに近いところへ向かって順に呼ばれていく。一
方、イベントは呼び上げられていく。いくつかの低レベルイベントはハードウエア割り込みに結
びつけられている（どのように結びつけられるかは基本的にはシステム依存であるので、本リフ
ァレンスマニュアルではこれ以上は述べない）。
・ コンポーネントはインタフェースを通じて互いに静的にリンクされる。これは実行時の効率を向
上させ、堅牢性を増し、プログラムのよりよい静的解析を可能とする。
・ nesC はコードがすべてコンパイラによって生成されるようにデザインされている。これによって
よりよいコード生成と解析が可能となる。例として nesC のコンパイル時のデータ競合検出があ
げられる。
・ nesCの並列処理モデルは処理完了まで走りきる（run-to-completion）タスクと割り込みハンド
ラに基づいている。割り込みハンドラはタスクや他の割り込みハンドラに割り込むことができる。
nesC コンパイラは割り込みハンドラが起こしうる潜在的なデータ競合を通知してくれる。

\subsubsection{コンポーネント図}

\subsubsection{ZigBeeノード}

%\appendix programming_code

\subsubsection{ZigBee基地局}

%\appendix programming_code

\begin{itemize}
 \item[$\clubsuit$]：シリアル信号待機状態
 \item E1：制御PCから信号を受信する
 \item G1：信号の受信成功
 \item A1：CTS-Blocking有効時間を測るためのタイマを起動する
 \item S2：ブロードキャスト準備状態
 \item A2：ZigBeeノードへブロードキャストする
 \item S3：受信待機状態
 \item E3：ZigBeeノードからデータを受信する
 \item G3：データの受信成功
 \item A3：コンソールにデータを表示する
 \item S4：受信完了状態
 \item E3'，E4'：タイマが完了する
 \item A3'，A4'：タイマをリセットする
\end{itemize}

\section{シーケンス図}

図\ref{fig:4_03}にシステム全体のシーケンス図を示す．
シーケンス図は，オブジェクト間の相互作用を時系列に沿って表現するダイアグラムである．
シーケンス図での時間は，ライフラインに沿って上から下に進む．
ここでは制御PCを含めた，システム全体の処理の流れが確認できる．

\subsubsection{制御PC}

同様に，図\ref{fig:4_03}に，ZigBeeノードのステートマシン図を示す．
ZigBeeノードに起こるイベントEv及びイベントハンドラEvH
（イベントが発生した際に実行すべきサブルーチン）は以下の通りである．

\begin{itemize}
 \item A 
 \item B
 \item C
\end{itemize}

従って，状態は

\begin{itemize}
 \item A 
 \item B
 \item C
\end{itemize}

の3つが存在すれば良いため，図\ref{fig:4_03}の様に作成した．

\end{document}

%付録
%\appendix

%索引
%printindex

%項
%\subsection{}
%目
%\subsubsection{}
%段落
%\paragraph{}
%小段落
%\subparagraph{}

%In-System Programming (インシステム プログラミング、ISP) とは、ある種のPLDやマイクロコントローラやその他プログラム可能な電子部品において、事前にプログラムを書き込んでからシステムに組み込むのではなく、組み込み済みの状態でプログラムを書き込むことである。
%この機能の主な利点は、システムの組み立て前に書き込み段階を別途設ける必要が無く、電子機器の製造者がプログラムの書き込みとテストを一つの製造工程で行なえることである。書き込み済みチップをそのメーカーや代理店から購入する代わりに、製造者がシステムの製造ラインでチップへの書き込みができるので、生産期間の途中でもコードや設計の変更が可能となる。
%一般的に ISP をサポートしたチップは、書き込みに必要なすべての電圧をシステムの通常の供給電圧から作り出す回路を内部に持っており、ライタとはシリアルプロトコルで通信する。多くの PLD では、自動化したテスト手順との統合が簡単になるように、ISP に JTAG プロトコルの一種を使っている。それ以外のデバイスでは、通常は独自のプロトコルや古い規格で定義されたプロトコルを使う。ある程度の規模のグルーロジックが必要となるような複雑なシステムでは、JTAG に対応していないフラッシュメモリやマイクロコントローラのようなデバイス用に、JTAG 制御の書き込みサブシステムを実装した設計が行なわれることもある。そのようにすれば、書き込みとテストのすべての手順を一つのプロトコルの制御下で行なえるからである。
